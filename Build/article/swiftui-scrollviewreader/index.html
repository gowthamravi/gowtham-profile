<!doctype html><html lang="en" data-bs-theme="light"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="I recently undertook a rewrite of most of the user interface in my app Pocket Bot. This presented me with the opportunity to start the adoption of SwiftUI. There were a few stumbling blocks and lessons learned, but overall went rather smoothly. That is until I started looking into updating my tvOS version."><meta name="author" content="Gowtham"><meta name="generator" content="Ignite v0.1.0"><title>SwiftUI ScrollViewReader</title><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/prism-default-dark.css" rel="stylesheet"><link href="/css/bootstrap-icons.min.css" rel="stylesheet"><link href="https://richardpiazza.com/article/swiftui-scrollviewreader" rel="canonical"><meta property="og:site_name" content="Gowtham Profile"><meta property="og:title" content="SwiftUI ScrollViewReader"><meta property="twitter:title" content="SwiftUI ScrollViewReader"><meta property="og:description" content="SwiftUI ScrollViewReader"><meta name="twitter:description" content="SwiftUI ScrollViewReader"><meta property="og:url" content="https://richardpiazza.com/article/swiftui-scrollviewreader"><meta name="twitter:domain" content="richardpiazza.com"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:dnt" content="on"></head><body class="container"style="padding-top: 80px; padding-bottom: 80px"><div class="col-sm-10 mx-auto"><header><nav class="fixed-top navbar navbar-expand-md"style="background-color: rgb(178 34 34 / 100%)" data-bs-theme="dark"><div class="container-fluid col"><a href="/" class="navbar-brand"><img src="/images/logo.svg"  class="mx-auto"style="width: min(60vw, 300px); height: 100%"alt="Gowtham profile"/></a><button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button><div id="navbarCollapse" class="collapse navbar-collapse"><ul class="navbar-nav mb-2 mb-md-0 col justify-content-end"><li class="nav-item"><a href="/about" class="nav-link">About</a></li><li class="nav-item dropdown" data-bs-theme="light"><a href="#" role="button" class="dropdown-toggle nav-link" data-bs-toggle="dropdown" aria-expanded="false">@gowtham</a><ul class="dropdown-menu"><li><a href="/about" class="dropdown-item">GitHub</a></li><li><a href="https://linkedin.com/in/richardpiazza" class="dropdown-item">LinkedIn</a></li><li><a href="https://mastodon.social/@richardpiazza" class="dropdown-item">Mastodon</a></li></ul></li></ul></div></div></nav></header><p>SwiftUI ScrollViewReader</p><p>I recently undertook a rewrite of most of the user interface in my app Pocket Bot. This presented me with the opportunity to start the adoption of SwiftUI. There were a few stumbling blocks and lessons learned, but overall went rather smoothly. That is until I started looking into updating my tvOS version.</p><p><p>I recently undertook a rewrite of most of the user interface in my app <a href="https://apps.apple.com/us/app/pocket-bot-for-xcode-server/id1024397029"><strong>Pocket Bot</strong></a>. This presented me with the opportunity to start the adoption of SwiftUI. There were a few stumbling blocks and lessons learned, but overall went rather smoothly. That is until I started looking into updating my tvOS version.</p><p>When running on tvOS, <em>Pocket Bot</em>, runs as a single dashboard, bringing together all of the information from multiple Xcode Servers. Often, the content needing to be displayed is larger than the space available. I originally solved this by implementing a <code>Timer</code> that would automatically scroll a <code>UITableView</code> every few seconds as needed. This was one of the biggest hurdles I had to overcome moving to SwiftUI.</p><p>Luckily though, Apple released the <code>ScrollViewReader</code> along with other SwiftUI improvements at WWDC 2020. The <a href="https://developer.apple.com/documentation/swiftui/scrollviewreader">ScrollViewReader</a> allows you to interact with the current scroll position of a <code>ScrollView</code>.</p><p>So let’s take a look at how I solved this translation of functionality by taking a look at <code>AutoRevealView</code>:</p><p>First, lets start with a simple source of data.</p><pre><code class="language-swift">enum Alphabet: String, CaseIterable, Identifiable {
    case a, b, c, d, e, f, g, h, i, j, k, l, m, n, o,
    p, q, r, s, t, u, v, w, x, y, z
    
    var id: String { rawValue }
}
</code></pre><p>Next, we’ll define our view.</p><pre><code class="language-swift">struct AutoRevealView<Content: Identifiable>: View {
    let contents: [Content]

    init(_ contents: [Content]) {
        self.contents = contents
    }

    var body: some View {
        Text("Hello World")
    }
}
</code></pre><p>Notice here, we are using Swift generics to allow for any content to be presented - as long as it conforms to the <code>Identifiable</code> protocol (more on that later).</p><p>If we were to preview this view, it would display the static text “Hello World” reguardless of the content, so let’s adapt the <code>body</code> to display our content.</p><pre><code class="language-swift">struct AutoRevealView<Content: Identifiable>: View {
    let contents: [Content]

    init(_ contents: [Content]) {
        self.contents = contents
    }

    var body: some View {
        VStack {
            ForEach(contents, id: \.id) { content in
                Text("\(content.id.hashValue)")
            }
        }
    }
}
</code></pre><p>This will display the correct number of rows for our content, but it’s not very interesting. Right now, all we know is that our <code>Content</code> conforms to <code>Identifiable</code>, meaning that it has an <code>id</code> property. In our <code>ForEach</code>, we don’t even have a way of determining if the id is a <code>String</code>, or <code>Int</code>, or something else.</p><p>Since we want to be able to reuse this code for any type of content, we’re going to need a way to provide a <code>View</code> that knows more about the <code>Content</code> being provided. Let’s extend our code to add another parameter - a @ViewBuilder - that will take one parameter: an instance of our <code>Content</code>.</p><pre><code class="language-swift">struct AutoRevealView<Content: Identifiable, ContentView: View>: View {
    let contents: [Content]
    let contentView: (_ content: Content) -> ContentView

    init(
        _ contents: [Content],
        @ViewBuilder contentView: @escaping (_ content: Content) -> ContentView
    ) {
        self.contents = contents
        self.contentView = contentView
    }

    var body: some View {
        ScrollView {
            ForEach(contents, id: \.id) { content in
                contentView(content)
            }
        }
    }
}
</code></pre><p>The instantiation of our View would now look something like this:</p><pre><code class="language-swift">let view = AutoRevealView(Alphabet.allCases) { content in
    VStack {
        Text(content.rawValue)
        Divider()
    }
}
</code></pre><p>Because of the generics, we know the type of <code>Content</code> being provided, and that content type can be referenced in the block being provided to construct a view. Now we’re getting somewhere!</p><p>Let’s keep going. It’s time to introduce our new friend <code>ScrollViewReader</code>. Do you remember how <code>Content</code> had to conform to <code>Identifiable</code>? Well that’s to our advantage here. We can use unique ids with <code>ScrollViewReader</code> to have SwiftUI modify the scroll view position. So, we’ll add a way to track the current ID and what happens when that id changes.</p><pre><code class="language-swift">struct AutoRevealView<Content: Identifiable, ContentView: View>: View {
    let contents: [Content]
    let contentView: (_ content: Content) -> ContentView
    @State var id: Content.ID? = nil

    init(
        _ contents: [Content],
        @ViewBuilder contentView: @escaping (_ content: Content) -> ContentView
    ) {
        self.contents = contents
        self.contentView = contentView
    }

    var body: some View {
        ScrollViewReader { reader in
            ScrollView {
                ForEach(contents, id: \.id) { content in
                    contentView(content)
                }
            }.onChange(of: id, perform: { _ in
                if let contentId = id {
                    withAnimation() {
                        reader.scrollTo(contentId, anchor: .top)
                    }
                }
            })
        }
    }
}
</code></pre><p>Wait, wasn’t this called the <em>Auto</em> RevealView? That’s not very automatic. In order to achieve that, we need one final piece: a Timer to allow for the incrementing of the current id.</p><pre><code class="language-swift">struct AutoRevealView<Content: Identifiable, ContentView: View>: View {
    let contents: [Content]
    let contentView: (_ content: Content) -> ContentView
    @State var id: Content.ID? = nil
    let timer: Publishers.Autoconnect<Timer.TimerPublisher>

    init(
        _ contents: [Content],
        @ViewBuilder contentView: @escaping (_ content: Content) -> ContentView
    ) {
        self.contents = contents
        self.contentView = contentView
        timer = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()
    }

    var body: some View {
        ScrollViewReader { reader in
            ScrollView {
                ForEach(contents, id: \.id) { content in
                    contentView(content)
                }
            }.onChange(of: id, perform: { _ in
                if let contentId = id {
                    withAnimation() {
                        reader.scrollTo(contentId, anchor: .top)
                    }
                }
            })
        }
        .onReceive(timer, perform: { _ in
            scrollToNext()
        })
    }
    
    func scrollToNext() {
        guard let contentId = id else {
            id = contents.first?.id
            return
        }
        
        guard let index = contents.firstIndex(where: { $0.id == contentId }) else {
            id = contents.first?.id
            return
        }
        
        if contents.count > index + 1 {
            id = contents[index + 1].id
        } else {
            id = contents[0].id
        }
    }
}
</code></pre><p>There we go! <code>.onReceive</code> will be trigger each time the Timer fires, which in turn updates the <code>@State id</code>. When a state variable is changed, SwiftUI does it’s thing and re-creates our view.</p><hr /><p>I hope you learned a little from this. If you have any questions or comments feel free to get in touch. Happy Coding!</p></p><p class="text-center mt-5">Created with <a href="https://github.com/twostraws/Ignite">Ignite</a></p></div><script src="/js/bootstrap.bundle.min.js"></script><script src="/js/syntax-highlighting.js"></script></body></html>